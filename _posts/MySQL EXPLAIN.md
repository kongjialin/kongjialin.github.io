EXPLAIN是个近似结果，限制：  

- EXPLAIN不会告诉你触发器、存储过程或UDF会如何影响查询  
- 它并不支持存储过程  
- 它不会告诉你MySQL在查询执行中所做的特定优化  
- 并不会显示关于查询执行计划的所有信息  
- 并不区分具有相同名字的事物。例如，对内存排序和临时文件都使用“filesort”，对磁盘和内存中的临时表都显示“Using temporary”  
- 可能会误导  

MySQL的新版本可能支持EXPLAIN非SELECT查询。旧版本的EXPLAIN只能解释SELECT查询，然而，可以重写某些非SELECT查询以利用EXPLAIN，即将该语句转化成一个等价的访问所有相同列的SELECT。任何提及的列都必须在SELECT列表、关联子句或者WHERE子句中。然而，对于写查询其实没有等价的读查询，一个SELECT只需找到数据的一份副本并返回，而任何修改数据的查询必须在所有索引上查找并修改其所有副本。

### EXPLAIN中的列  
输出中的行以MySQL实际执行的查询部分的顺序出现，这个顺序不总是与其在原始SQL中的相一致。  

- id 列  
  编号，标识SELECT所属的行  
- select_type 列  
  显示了对应行是简单还是复杂SELECT，复杂类型又分为三大类：简单子查询、派生表（例如在FROM子句中的子查询）、以及UNION查询。SIMPLE值意味着查询不包括子查询和UNION，如果查询有任何复杂的子部分，则最外层部分标记为PRIMARY，其他部分标记如下：    
  - SUBQUERY  
    包含在SELECT列表中的子查询中的SELECT（不在FROM子句中）  
  - DERIVED  
    包含在FROM子句的子查询中的SELECT，MySQL会递归执行并将结果放到一个临时表中  
  - UNION  
    在UNION中的第二个和随后的SELECT被标记为UNION  
  - UNION RESULT  
    表示用来从UNION的匿名临时表检索结果的SELECT  
  
  除了这些值，SUBQUERY和UNION还可以被标记为DEPENDENT和UNCACHEABLE。DEPENDENT意味着SELECT依赖于外层查询中发现的数据，UNCACHEABLE意味着SELECT中的某些特性阻止结果被缓存于一个Item_cache中。  
- table 列  
  显示了对应行正在访问哪个表。当在FROM子句中有子查询时，table列是<derivedN>的形式，其中N是子查询的id，指向EXPLAIN输出中后面的一行。当有UNION时，UNION RESULT的table列包含一个参与UNION的id列表。  
- type 列  
  显示了访问类型，即MySQL决定如何查找表中的行，从最差到最优的访问方法为：  
  - ALL  
    全表扫描（例外：使用了LIMIT，或者在Extra列中显示“Using distinct/not exists”）
  - index  
    跟全表扫描一样，只是扫描按索引次序进行而不是行。优点是避免了排序，最大的缺点是要承担按索引次序读取整个表的开销，即要是按随即次序访问行，开销会很大。  
    如果在Extra列中看到“Using index”，说明正在使用覆盖索引，它只扫描索引的数据，而不是按索引次序的每一行，它比按索引次序全表扫描的开销要少很多  
  - range  
    范围扫描，就是一个有限制的索引扫描。这比全索引扫描好些，因为不用遍历全部索引。范围扫描是带有BETWEEN或在WHERE子句里带有>的查询。  
    当MySQL使用索引去查找一系列值时，例如IN()和OR列表，也会显示为范围扫描，然而，它们是相当不同的访问类型，在性能上有重要差异。  
    此类扫描的开销跟索引类型相当。  
  - ref  
    是一种索引访问（有时也叫做索引查找），它返回所有匹配某个单个值的行。然而，它可能会找到多个符合条件的行，因此，它是查找和扫描的混合体。此类索引访问只有当使用非唯一性索引或者唯一性索引的非唯一性前缀时才会发生。把它叫做ref是因为索引要跟某个参考值相比较，这个参考值或者是一个常数，或者是来自多表查询前一个表里的结果值。   
    ref_or_null是ref之上的一个变体，意味着必须在初次查找的结果里进行第二次查找以找出null条目。  
  - eq_ref  
    使用这种索引查找，MySQL知道最多只返回一条符合条件的记录。这种访问方法可以在使用主键或者唯一性索引查找时看到，它会将它们与某个参考值作比较。  
  - const，system  
    当MySQL能对查询的某部分进行优化并将其转换成一个常量时，它就会使用这些访问类型  
  - NULL  
    意味着MySQL能在优化阶段分解查询语句，在执行阶段甚至用不着再访问表（或者索引）  
- possible_keys 列  
  这一列显示了可以使用哪些索引，这是基于查询访问的列和使用的比较操作符来判断的。这个列表是在优化过程的早期创建的，因此有些罗列出来的索引可能对于后续优化过程是没用的。  
- key 列  
  这一列显示了MySQL决定采用哪个索引来优化对该表的访问。如果该索引没有出现在possible_keys列中，那么MySQL选用它是出于另外的原因。  
  possible_keys揭示了哪一个索引有助于高效地进行查找，而key显示的是优化采用哪一个索引可以最小化查询成本。  
- key_len 列  
  显示了MySQL在索引里使用的字节数（可能的最大长度）。如果正在使用的只是索引里的某些列，那么就可以用这个值来算出具体是哪些列  
- ref 列  
  显示了之前的表在key列记录的索引中查找值所用的列或常量  
- rows 列  
  这一列是MySQL估计为了找到所需的行而需要读取的行数，它不是MySQL认为它最终要从表里读取出来的行数，而是MySQL为了找到符合查询的每一点上标准的那些行而必须读取的行的平均数。  
  通过把所有行的rows列相乘，可以粗略地估算出整个查询会检查的行数。  
- filtered 列  
  该列在使用EXPALIN EXTENDED时出现。它显示的是针对表里符合某个条件（WHERE子句或联接条件）的记录数的百分比所做的一个悲观估算。如果把rows列和这个百分比相乘，就能看到MySQL估算它将和查询计划里前一个表关联的行数。  
- Extra 列    
  常见的值如下：    
  - Using index  
    表示MySQL将使用覆盖索引，以避免访问表  
  - Using where  
    表示MySQL服务器将在存储引擎检索行后再进行过滤  
  - Using temporary  
    表示MySQL在对查询结果排序时会使用一个临时表  
  - Using filesort  
    表示MySQL会对结果使用一个外部索引排序，而不是按索引次序从表里读取行  
  - Range checked for each record (index map: N)  
    表示没有好用的索引，新的索引将在联接的每一行上重新估算  