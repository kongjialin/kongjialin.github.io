---
layout: post
title: 01背包及扩展
subtitle: 求解最大价值及取得最大价值的物品组合
---

## Problem
给定n个物品，大小为size[i]，价值为val[i]，要装入一个容量为m的背包，问能够得到的最大价值为多大？

Follow up 1: 输出组成最大价值的物品组合，如果有多种组合，输出下标最小的组合。

Follow up 2: 输出组成最大价值的所有组合。

## Solution
**Original Problem**

Solution 1: 二维DP

状态：dp[i][j] -- 从物品0到物品i，达到容量j时，能够得到的最大价值

递推关系（物品i不选或者选）：dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - size[i]] + val[i])

初始条件：dp[i][0] = 0, if (m >= size[0]) dp[0][size[0]] = val[0]

所求结果：max{dp[n - 1][j], j = 0, ..., n - 1}

{% highlight javascript linenos %}
void Backpack(int m, vector<int>& size, vector<int>& val) {
  int n = size.size();
  vector<vector<int> > dp(n, vector<int>(m + 1, -1));
  for (int i = 0; i < n; ++i)
    dp[i][0] = 0;
  if (m >= size[0]) dp[0][size[0]] = val[0];
  for (int i = 1; i < n; ++i) {
    for (int j = 1; j <= m; ++j) {
      dp[i][j] = dp[i - 1][j];
      if (j >= size[i] && dp[i - 1][j - size[i]] != -1 &&
          dp[i - 1][j - size[i]] + val[i] > dp[i - 1][j])
        dp[i][j] = dp[i - 1][j - size[i]] + val[i];
    }
  }
  int max_val = 0;
  for (int j = 0; j <= m; ++j) {
    if (dp[n - 1][j] > max_val) max_val = dp[n - 1][j];
  }
  cout << max_val << endl;
}
{% endhighlight %}


Here's a code chunk:

~~~
x <- 5 + 10
print(x)
~~~

And here is some code with syntax highlighting

{% highlight javascript linenos %}
var foo = function(x) {
  return(x + 5);
}
foo(3)
{% endhighlight %}
